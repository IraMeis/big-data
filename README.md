# big-data

### LR1  
Station и Trip - вспомогательные классы (из нотебуков с 
интерактивным питоном).  

**1. Найти велосипед с максимальным временем пробега.**  
Маппинг объектов в пары (айди велосипеда + время поездки),
далее редукция по айди и лимитирование (top(),
совокупное время пробега в качестве ключа) до 1 элемента.


**2. Найти наибольшее геодезическое расстояние между станциями.**  
~~Сначала я пыталась найти расстояние, ориентируясь на время
поезок, а потом поняла что в данных есть координаты~~  
Находятся все пары станций (декартово произведение),
далее маппинг в объекты с данными о геодезическом 
расстоянии. Top выводит данные по паре станций с наибольшим
расстоянием.

**3. Найти путь велосипеда с максимальным временем пробега через станции.**  
Велосипед с максимальным пробегом известен (пункт 1).
Выполняется фильтрация поездок по айди данного
велосипеда, далее сортировка по дате (восстановить маршрут
хронологически) и урезание выборки до кортежа
из названий интересующих станций.

**4. Найти количество велосипедов в системе.**  
Маппинг записей в айди, далее удаление дубликатов
(distinct()) и подсчет оставшегося.

**5. Найти пользователей потративших на поездки более 3 часов.**  
Фильтрация по времени поездки, далее оставляем только 
айди велосипедиста (map в zip_code), чистим от
пустых строк (перестраховка по сути) и убираем дубликаты.

### LR2
**Логика обработки данных:**  
В цикле для каждого года из заданного интервала
происходит фильтрация по принадлежности к году (+ проверка
на непустой тег), находятся языки в тегах (в тегах,
потому что если искать какой-нибудь C или R в
основном тексте, то будет много мусора), убираются
пустые занчения, считается количество упоминаний
языка в годе, происходит сортировка по количеству 
упоминаний (от большего к меньшему), отчет
урезается до топ 10 искомых языков.  

**Вспомогательные функции:**  
find_language - ищет язык в тегах без учета регистра     
is_year_date - проверяет принадлежность записи к году по дате создания  

### LR3  
Задания сделаны на Java. Скрины пройденных тестов
в папке lr3, основной репозиторий добавлен как
сабмодуль (flink-training-exercises).

**RideCleansingExercise**  
[go to code](https://github.com/IraMeis/flink-training-exercises/blob/master/src/main/java/com/ververica/flinktraining/exercises/datastream_java/basics/RideCleansingExercise.java)  
Фильтр переопределен возвращать true, если
начальные и конечные координаты в пределах
границ NYC (функция проверки нашлась в GeoUtils).  

**RidesAndFaresExercise**  
[go to code](https://github.com/IraMeis/flink-training-exercises/blob/master/src/main/java/com/ververica/flinktraining/exercises/datastream_java/state/RidesAndFaresExercise.java)    
Метод open инициализирует две переменные состояния, 
rideState и fareState (для сохранения текущих
TaxiRide и TaxiFare).  

В методе flatMap1, когда встречается событие TaxiRide, 
оно сохраняется в rideState. Если в fareState
есть соответствующий TaxiFare, генерируется 
новый tuple, fareState сбрасывается.  

В методе flatMap2 при обнаружении события 
TaxiFare, оно сохраняется в fareState. Если в rideState 
есть соответствующий TaxiRide, генерируется
новый tuple, rideState сбрасывается.  

**HourlyTipsExerxise**  
[go to code](https://github.com/IraMeis/flink-training-exercises/blob/master/src/main/java/com/ververica/flinktraining/exercises/datastream_java/windows/HourlyTipsExercise.java)   
Сначала группируем по id водителя TaxiFare,
потом группируем данные по каждому часу 
для каждого водителя, в process считаем заработанное 
водителем за каждый час. Далее производим 
перегруппировку через timeWindowAll (создание окон
по часам без разделения по id водителя) и
для каждого часа находим максимальную 
разаботанную сумму.

**ExpiringStateExercise**  
[go to code](https://github.com/IraMeis/flink-training-exercises/blob/master/src/main/java/com/ververica/flinktraining/exercises/datastream_java/process/ExpiringStateExercise.java)   
Два объекта ValueState создаются для сохранения 
актуальных TaxiRide и TaxiFare для данного rideId,
инициализируются в методе open.

processElement1:  
Если соответствующий ride'y TaxiFare существует,
создается новый кортеж, состояние TaxiFare сбрасывается.
Если соответствующий TaxiFare не найден, 
текущий TaxiRide сохраняется в rideState, и 
регистрируется таймер. 
Таймер используется для очистки состояния, 
если в течение указанного времени TaxiFare 
не будет найден.

processElement2:  
Если соответствующий fare'e TaxiRide существует,
создается новый кортеж, состояние TaxiRide сбрасывается.
Если соответствующий TaxiRide не найден,
текущий TaxiFare сохраняется в fareState, и
регистрируется таймер.
Таймер используется для очистки состояния,
если в течение указанного времени TaxiRide
не будет найден.

onTimer:  
Когда срабатывает таймер, зарегистрированный в методе
processElement1 или processElement2, это означает, 
что в течение указанного времени не поступило ни 
одного подходящего события.
В этом случае код проверяет как rideState, так и 
fareState, чтобы определить, есть ли какие-либо 
несогласованные события.
Если в fareState или rideState найдены несогласованные 
данные, они передаюся соответственно в 
unmatchedFares или unmatchedRides, состояния сбрасываюстся.

### LR4  
Задания сделаны на Python (kazoo), расположены
в lr4. В сабмодуле lr-zookeeper кусок первой части лр 
(с готовым классом Animal).  

**Проблема обедающих философов**  
Каждый филосов - Thread, для которого run 
переопределен создавать подключение к
zookeeper и далее запускать в несколько итераций 
eat() и think(), поел-подумал N раз. eat()
каждый раз создает эфимерную ноду, think() ее
удаляет, на последней итерации закрывает соединение.
Вилки сделаны как threading.Semaphore(1), т.е.
кажадя вилка лочится одним потоком, который ее 
успел "забрать". Поучавтсвовать в перехвате
вилок могут одновременно N-1 шт. потоков
(тоже семафор, блок между self.mutex.acquire() 
и self.mutex.release()), сделано для исключения 
ситуации "все схватили по 1 левой и ждут".

**Двуфазный коммит протокол**  
Реализован второй вариант. Все процессы -
Thread'ы. Координатор создает
тразнакционный узел (это событие также 
является "уведомлением",
пока узел не создан, ноды спят) и подписывается на
измененния созданного узла. Исполнители создают 
эфимерные узлы с решением (коммит/аборт 
для лабы выбирается случайно) и подписыватся на
изменения данных своих узлов. После того как 
все ноды создаут узлы либо выйдет timeout,
координатор считывает данные, принимает решение
(н-р "мажоритарное голосование" или "откатить, если 
есть хотя бы 1 аборт"), ноды коммитят/абортят 
транзакцию.
