# big-data

### LR1  
Station и Trip - вспомогательные классы (из нотебуков с 
интерактивным питоном).  

**1. Найти велосипед с максимальным временем пробега.**  
Маппинг объектов в пары (айди велосипеда + время поездки),
далее редукция по айди и лимитирование (top(),
совокупное время пробега в качестве ключа) до 1 элемента.


**2. Найти наибольшее геодезическое расстояние между станциями.**  
~~Сначала я пыталась найти расстояние, ориентируясь на время
поезок, а потом поняла что в данных есть координаты~~  
Находятся все пары станций (декартово произведение),
далее маппинг в объекты с данными о геодезическом 
расстоянии. Top выводит данные по паре станций с наибольшим
расстоянием.

**3. Найти путь велосипеда с максимальным временем пробега через станции.**  
Велосипед с максимальным пробегом известен (пункт 1).
Выполняется фильтрация поездок по айди данного
велосипеда, далее сортировка по дате (восстановить маршрут
хронологически) и урезание выборки до кортежа
из названий интересующих станций.

**4. Найти количество велосипедов в системе.**  
Маппинг записей в айди, далее удаление дубликатов
(distinct()) и подсчет оставшегося.

**5. Найти пользователей потративших на поездки более 3 часов.**  
Фильтрация по времени поездки, далее оставляем только 
айди велосипедиста (map в zip_code), чистим от
пустых строк (перестраховка по сути) и убираем дубликаты.

### LR2
**Логика обработки данных:**  
В цикле для каждого года из заданного интервала
происходит фильтрация по принадлежности к году (+ проверка
на непустой тег), находятся языки в тегах (в тегах,
потому что если искать какой-нибудь C или R в
основном тексте, то будет много мусора), убираются
пустые занчения, считается количество упоминаний
языка в годе, происходит сортировка по количеству 
упоминаний (от большего к меньшему), отчет
урезается до топ 10 искомых языков.  

**Вспомогательные функции:**  
find_language - ищет язык в тегах без учета регистра     
is_year_date - проверяет принадлежность записи к году по дате создания  

### LR3  
Задания сделаны на Java. Скрины пройденных тестов
в папке lr3, основной репозиторий добавлен как
сабмодуль.

**RideCleansingExercise**  
Фильтр переопределен возвращать true, если
начальные и конечные координаты в пределах
границ NYC (функция проверки нашлась в GeoUtils).  

**RidesAndFaresExercise**  
Метод open инициализирует две переменные состояния, 
rideState и fareState (для сохранения текущих
TaxiRide и TaxiFare).  

В методе flatMap1, когда встречается событие TaxiRide, 
оно сохраняется в rideState. Если в fareState
есть соответствующий TaxiFare, генерируется 
новый tuple, fareState сбрасывается.  

В методе flatMap2 при обнаружении события 
TaxiFare, оно сохраняется в fareState. Если в rideState 
есть соответствующий TaxiRide, генерируется
новый tuple, rideState сбрасывается.  

**HourlyTipsExerxise**  
Сначала группируем по id водителя TaxiFare,
потом группируем данные по каждому часу 
для каждого водителя, в process считаем заработанное 
водителем за каждый час. Далее производим 
перегруппировку через timeWindowAll (создание окон
по часам без разделения по id водителя) и
для каждого часа находим максимальную 
разаботанную сумму.

**ExpiringStateExercise**  
Два объекта ValueState создаются для сохранения 
актуальных TaxiRide и TaxiFare для данного rideId,
инициализируются в методе open.

processElement1:  
Если соответствующий ride'y TaxiFare существует,
создается новый кортеж, состояние TaxiFare сбрасывается.
Если соответствующий TaxiFare не найден, 
текущий TaxiRide сохраняется в rideState, и 
регистрируется таймер. 
Таймер используется для очистки состояния, 
если в течение указанного времени TaxiFare 
не будет найден.

processElement2:  
Если соответствующий fare'e TaxiRide существует,
создается новый кортеж, состояние TaxiRide сбрасывается.
Если соответствующий TaxiRide не найден,
текущий TaxiFare сохраняется в fareState, и
регистрируется таймер.
Таймер используется для очистки состояния,
если в течение указанного времени TaxiRide
не будет найден.

onTimer:  
Когда срабатывает таймер, зарегистрированный в методе
processElement1 или processElement2, это означает, 
что в течение указанного времени не поступило ни 
одного подходящего события.
В этом случае код проверяет как rideState, так и 
fareState, чтобы определить, есть ли какие-либо 
несогласованные события.
Если в fareState или rideState найдены несогласованные 
данные, они передаюся соответственно в 
unmatchedFares или unmatchedRides, состояния сбрасываюстся.